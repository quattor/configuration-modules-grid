#${PMpre} NCM::Component::pbsserver${PMpost}

use parent qw(NCM::Component CAF::Path);

our $EC = LC::Exception::Context->new->will_store_all;
our $NoActionSupported = 1;

use CAF::Process;
use CAF::Service;
use CAF::FileWriter;

use Readonly;

# Filter out any matching pbsnodes attributes from further processing
Readonly::Array my @FILTER_PBSNODES_PATTERNS => qw(
    state ntype power_state
    status jobs note
    mom_(manager|service)_port
    (total|dedicated)_(sockets|numa_nodes|cores|threads)
    gpus gpu_status
);


# Location of the qmgr binary (needs to be determined and set once)
my $qmgr;


sub Configure
{
    my ($self, $config) = @_;

    # Define paths for convenience and retrieve configuration
    my $tree = $config->getTree($self->prefix());


    # Retrieve location for pbs working directory and ensure it exists.
    my $pbsroot = $tree->{pbsroot} || "/var/torque";

    if (! $self->directory($pbsroot)) {
        $self->error("Can't create directory $pbsroot: $self->{fail}");
        return 1;
    }

    my $srv = CAF::Service->new(['pbs_server'], log => $self);
    # set to true if service was (re)started
    my $started = 0;

    # Determine the location of the pbs commands.
    my $binpath = $tree->{binpath} || "/usr/bin";

    my $serverdb = "$pbsroot/server_priv/serverdb";
    if (! $self->file_exists($serverdb)) {
        $self->info("serverdb $serverdb is missing.");

        if (! $srv->stop()) {
            $self->warn('pbs_server stop failed before create (normal in not started yet): '. $?);
        };

        # force is ok, because the serverdb is missing
        return 1 if (! defined($self->force_create($binpath, $pbsroot)));

        $started = 1;
        if (! $srv->start()) {
            $self->warn('pbs_server start failed after create (normal because not configured yet): '. $?);
        };
    }

    # Retrieve the contents of the envrionment file and update if necessary/
    if ( $tree->{env} ) {
        my $fname = "$pbsroot/pbs_environment";
        $self->info("Checking environment file ($fname)...");
        my $contents = "#\n# File generated by ncm-pbsserver. DO NOT EDIT\n#\n";
        foreach my $name (sort keys %{$tree->{env}}) {
            $contents .= "$name=$tree->{env}->{$name}\n";
        }
        my $fh_env = CAF::FileWriter->new($fname,
                                          backup => ".old",
                                          log => $self,
                                          );
        print $fh_env $contents;

        if($fh_env->close()) {
            $self->verbose("$fname updated. Restarting pbs_server...");
            $started = 1;
            if (! $srv->restart()) {
                $self->error('pbs_server restart failed: '. $?);
            };
        }
    }


    # Update the submit filter.  This is used only by the qsub
    # command, so the server doesn't need to be restarted for changes
    # here.
    # Be very careful, the file will NOT work with embedded comments.
    if ( $tree->{submitfilter} ) {
        $self->info("Checking submission filter...");
        my $fh_cfg = CAF::FileWriter->new("$pbsroot/torque.cfg",
                                          backup => ".old",
                                          log => $self,
                                          );
        print $fh_cfg "SUBMITFILTER $pbsroot/submit_filter\n";
        $fh_cfg->close();

        my $fh_sf = CAF::FileWriter->new("$pbsroot/submit_filter",
                                         backup => ".old",
                                         mode => 0755,
                                         log => $self,
                                         );
        print $fh_sf $tree->{submitfilter};
        $fh_sf->close();

    # Ensure that any existing filter is removed.  Since the
    # submitfilter is the only parameter in torque.cfg, this file
    # can be removed as well.
    # this is far from true. if something else manages torque.cfg, set ignoretorquecfg to true
    } else {
        $self->info("Removing submission filter...");
        $self->cleanup("$pbsroot/submit_filter");

        my $removetorquecfg = $self->file_exists("$pbsroot/torque.cfg");
        if ($tree->{ignoretorquecfg}) {
            $removetorquecfg = 0;
            $self->info("Ignoring torque.cfg file.");
        };
        $self->cleanup("$pbsroot/torque.cfg") if ($removetorquecfg);
    }


    $self->set_qmgr("$binpath/qmgr");
    my $pbsnodes = "$binpath/pbsnodes";

    foreach my $bin ($qmgr, $pbsnodes) {
        if (! $self->file_exists($bin)) {
            $self->error("$bin does not exist");
            return 1;
        }
    }


    my $existing = $self->get_current_config($started);
    if (! defined($existing)) {
        $self->error("No existing config found");
        return 1;
    }


    # server configuration
    # $serverbase --+
    #               +--manualconfig : boolean
    #               +--attlist ? nlist
    # If manualconfig is false, remove any existing config parameter not part of the configuration.
    my %definedsatt;
    if ( $tree->{server} ) {
        $self->info("Updating server attributes...");
        if ( $tree->{server}->{attlist} ) {
            my $server_attlist = $tree->{server}->{attlist};
            foreach my $serveratt (sort keys %{$server_attlist}) {
                $definedsatt{$serveratt} = 1;
                $self->qmgr("set server $serveratt = ".$server_attlist->{$serveratt});
            }
        }

        # Removing server attributes not defined in configuration if manualconfig is set to false.
        # Take care of not removing a few attributes generated/maintained by the server.
        # 'acl_hosts' is defined to the server host name at startup if not explicitly defined.
        if ( $self->allowed($tree->{server}) ) {
            $self->debug(1,"Removing server attributes not part of the configuration (manualconfig=false)");
            foreach (sort keys %{$existing->{satt}}) {
                unless ( defined($definedsatt{$_}) ||
                        ($_ eq "pbs_version") ||
                        ($_ eq "acl_hosts") ||
                        ($_ eq "next_job_number") ) {
                    $self->qmgr("unset server $_");
                }
            }
        }
    }


    if ( $tree->{server}->{attlist}->{server_name} ) {
        my $fh = CAF::FileWriter->new("$pbsroot/server_name", log => $self);
        print $fh "$tree->{server}->{attlist}->{server_name}\n";
        if ($fh->close()) {
            $self->info("server_name file changed, restarting pbs_server");
            if (! $srv->restart()) {
                $self->error('pbs_server restart failed: '. $?);
            };
            # Wait till server responds again
            my $new_existing = $self->get_current_config(1);
            return 1 if (! defined($existing));
        }
    }

    # queue configuration
    # $queuebase --+
    #              +--manualconfig : boolean
    #              +--queuelist--+ ? nlist
    #                            +--manualconfig : boolean
    #                            +--attlist ? nlist
    # If manualconfig is false, remove any existing config parameter not part of the configuration.

    my %definedqueues;
    if ( $tree->{queue} ) {
        $self->info("Updating queue list and queue attributes...");
        if ( $tree->{queue}->{queuelist} ) {
            my $queuelist = $tree->{queue}->{queuelist};
            foreach my $queue (sort keys(%{$queuelist})) {
                $definedqueues{$queue} = 1;
                if (!$existing->{queues}->{$queue}) {
                    $self->qmgr("create queue $queue");
                }

                my %definedqatt;
                if ( $queuelist->{$queue}->{attlist} ) {
                    my $queue_attlist = $queuelist->{$queue}->{attlist};
                    foreach my $queueatt (sort keys(%{$queue_attlist})) {
                        $definedqatt{$queueatt} = 1;
                        # Ensure queue is enabled and started after the configuration has been done
                        if (($queueatt ne "enabled") && ($queueatt ne "started")) {
                            $self->qmgr("set queue $queue $queueatt = ".$queue_attlist->{$queueatt});
                        }
                    }
                    foreach my $queueatt ('enabled', 'started') {
                        if ( $definedqatt{$queueatt} ) {
                            $self->qmgr("set queue $queue $queueatt = ".$queue_attlist->{$queueatt});
                        }
                    }
                }

                # Removing non-defined queue attributes if manualconfig is set to false
                if ( $self->allowed($queuelist->{$queue}) ) {
                    $self->debug(1,"Removing queue $queue attributes not part of the configuration (manualconfig=false)");
                    foreach (sort keys %{$existing->{queues}->{$queue}}) {
                        $self->qmgr("unset queue $queue $_") unless (defined($definedqatt{$_}));
                    }
                }
            }
        }

        # Delete existing queues not part of the configuration if manualconfig is set to false
        if ( $self->allowed($tree->{queue}) ) {
            foreach (sort keys %{$existing->{queues}}) {
                unless (defined($definedqueues{$_})) {
                    $self->qmgr("delete queue $_", "Removing queue $_...");
                }
            }
        }
    }


    # This slurps the pbsnodes output into a hash of hashes.  This
    # avoids having to rerun the command.
    my %existingnodes;
    my $lastnode = '';

    my $nodesfn = "$pbsroot/server_priv/nodes";
    if ($self->file_exists($nodesfn)) {
        my $output = CAF::Process->new([$pbsnodes, '-a'], log => $self, keeps_state => 1)->output();
        if ($?) {
            $self->error("error running $pbsnodes");
            return 1;
        }

        my $filterpattern = '^(' . join('|', @FILTER_PBSNODES_PATTERNS) . ')$';
        my $filterregexp = qr{$filterpattern};
        $self->verbose("pbsnodes attributes filter regexp $filterregexp");

        foreach my $line (split(/\n/, $output)) {
            chomp($line);
            if ($line =~ m/(^[\w\d\.-]+)\s*$/) {
                # Start of a section with node name.
                $lastnode = $1;
                $existingnodes{$lastnode} = {};
            } elsif ($line =~ m/^\s*(\w+)\s*=\s*(.*)/) {
                # This is an attribute.  Attach it to last node.
                my $name = $1;
                my $value = $2;
                if ($lastnode && $name !~ $filterregexp) {
                    my $href = $existingnodes{$lastnode};
                    $href->{$name} = $value;
                }
            }
        }
    } else {
        $self->verbose("nodes file $nodesfn not found, not checking any exiting nodes");
    }


    # node configuration
    # $nodebase--+
    #            +--manualconfig : boolean
    #            +--nodelist--+ ? nlist
    #                         +--manualconfig : boolean
    #                         +--attlist ? nlist

    my %definednodes;
    if ( $tree->{node} ) {
        $self->info("Updating WN list and WN attributes...");
        if ( $tree->{node}->{nodelist} ) {
            my $nodelist = $tree->{node}->{nodelist};
            foreach my $node (sort keys %{$nodelist}) {
                $definednodes{$node} = 1;
                $self->qmgr("create node $node") unless (defined($existingnodes{$node}));

                # Retrieve node attributes and properties.
                # properties is a comma separated list.
                my %definednatt;
                my %existingnatt;
                my %defprops;
                if (defined($existingnodes{$node})) {
                    my $href = $existingnodes{$node};
                    %existingnatt = %$href;
                }
                if (defined($existingnatt{properties})) {
                    my @props = split /,/, $existingnatt{properties};
                    foreach my $p (@props) {
                        $defprops{$p} = 1;
                    }
                }

                if ( $nodelist->{$node}->{attlist} ) {
                    my $node_attlist = $nodelist->{$node}->{attlist};
                    foreach my $nodeatt (sort keys %{$node_attlist}) {
                        if ($nodeatt eq "properties") {
                            my @newprops = split /,/, $node_attlist->{$nodeatt};
                            foreach my $p (@newprops) {
                                if (defined($defprops{$p})) {
                                    delete $defprops{$p};
                                } else {
                                    $self->qmgr("set node $node $nodeatt += $p");
                                }
                            }
                        } else {
                            $definednatt{$nodeatt} = 1;
                            $self->qmgr("set node $node $nodeatt = ".$node_attlist->{$nodeatt});
                        }
                    }
                }

                # Removing non-defined node attributes if manualconfig is set to false
                if ( $self->allowed($nodelist->{$node}) ) {
                    $self->debug(1,"Removing node $node attributes not part of the configuration (manualconfig=false)");
                    # First delete properties not part of the configuration
                    foreach my $p (sort keys %defprops) {
                        $self->qmgr("set node $node properties -= '$p'");
                    }
                    # Delete attributes not part of the configuration
                    # Special and/or readonly attributes should be filtered from processing
                    # via FILTER_PBSNODES_PATTERNS or handled separately (like properties)
                    foreach (sort keys %existingnatt) {
                        if (!defined($definednatt{$_}) &&
                            ($_ ne 'properties')) {
                            $self->qmgr("unset node $node $_");
                        }
                    }
                }
            }
        }

        # Delete existing nodes not part of the configuration if manualconfig is set to false
        if ( $self->allowed($tree->{node}) ) {
            foreach (sort keys %existingnodes) {
                unless (defined($definednodes{$_})) {
                    $self->qmgr("delete node $_", "Removing node $_...");
                }
            }
        }
    }

    return 1;
}


# Set qmgr module variable to qmgr_bin (if defined)
# Returns value of qmgr
sub set_qmgr
{
    my ($self, $qmgr_bin) = @_;

    $qmgr = $qmgr_bin if defined($qmgr_bin);

    return $qmgr;
}


# For hashref cfg, return if component is allowed to make changes
# (it checks if the manualconfig attribute is set and false)
sub allowed
{
    my ($self, $cfg) = @_;

    return defined($cfg->{manualconfig}) && (!$cfg->{manualconfig});
}


# force (re)create the serverdb
sub force_create
{
    my ($self, $binpath, $pbsroot) = @_;

    my $sleep = 10;

    my $pbs_server_bin = "$binpath";
    # it's in sbin
    $pbs_server_bin =~ s/bin/sbin/;
    $pbs_server_bin .= "/pbs_server";
    $self->info("Trying with pbs_server $pbs_server_bin");
    my $output = CAF::Process->new([$pbs_server_bin, '-d', $pbsroot, '-t', 'create', '-f'], log => $self)->output();
    if ($?) {
        $self->error("Failed to create the server (ec $?): $output");
        return;
    };
    sleep $sleep;

    my $qterm = "$binpath/qterm";
    $output = CAF::Process->new([$qterm], log => $self)->output();
    if ($?) {
        $self->error("Failed to stop the server (ec $?), trying again: $output");
        sleep 2*$sleep;
        $output = CAF::Process->new([$qterm], log => $self)->output();
        if ($?) {
            $self->error("Failed to stop the server (ec $?) 2nd time, giving up: $output");
            return;
        };
    };

    return 1;
}

# execute qmgr with command cmd
# if optional msg is passed, report the message with info level
# if optional keeps_state is passed, run command with it
sub qmgr
{
    my ($self, $cmd, $msg, $keeps_state) = @_;
    $self->info($msg) if $msg;

    my $out = CAF::Process->new([$qmgr, "-c", $cmd], log => $self, keeps_state => $keeps_state ? 1 : 0)->output();
    if ($?) {
	   $self->error("Failed to run $qmgr $cmd: $out (", $? >> 8, ")");
    } else {
	   $self->debug(2, "qmgr $cmd successful");
    }
    return $out;
}

# Wait a bit for the server to become active in case it has been restarted.
# Check every 30s after the first try until it comes up; try for up to
# 5 minutes.
# Args:
#   started : start with 5 second sleep (in case recently (re)started)
# Return a hashref with server attributes and queue
# data from the current config on success; undef on failure.
sub get_current_config
{
    my ($self, $started) = @_;

    $self->info("Retrieving current configuration...");
    my $remaining = 10;
    sleep 5 if $started;
    my $current_config = $self->qmgr("print server", undef, 1);
    while ( $? && ($remaining > 0) ) {
        $self->info("waiting 30s for qmgr to respond; $remaining tries remaining");
        $remaining--;
        sleep 30;
        $current_config = $self->qmgr("print server", undef, 1);
    }
    if ( $? ) {
        $self->error("qmgr is not responding; aborting configuration");
        return;
    }

    my $existing;
    foreach my $line (split('\n', $current_config)) {
        chomp $line;
        if ($line =~ m/set server ([\w\.]+)/) {
            # Mark the server attribute as set.
            $existing->{satt}->{$1} = 1;

        } elsif ($line =~ m/create queue ([\w\.\-]+)/) {
            # Create a hash for the queue.
            $existing->{queues}->{$1} = {};

        } elsif ($line =~ m/set queue ([\w\.\-]+)\s+([\w\.]+)/) {
            # Mark the attribute as set for the given queue.
            my $queue = $1;
            my $name = $2;
            $existing->{queues}->{$queue}->{$name} = 1;
        }
    }
    return $existing;
}


1;      # Required for PERL modules
