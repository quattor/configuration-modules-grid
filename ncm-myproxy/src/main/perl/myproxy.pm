# ${license-info}
# ${developer-info}
# ${author-info}
# ${build-info}
#

package NCM::Component::myproxy;

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;
use NCM::Check;
use CAF::Process;

use EDG::WP4::CCM::Element;

use File::Copy;
use File::Path;

local(*DTA);

# Match between componenent properties and MyProxy configuration keywords.
# For each properties, there may be several options needed thus the value is a list.
my %myproxy_options = ('defaultDNs-renewers' => ['default_renewers'],
                     'defaultDNs-retrievers' => ['default_retrievers'],
                     'defaultDNs-keyRetrievers' => ['default_key_retrievers'],
                     'defaultDNs-trustedRetrievers' => ['default_trusted_retrievers','default_retrievers'],
                     'authorizedDNs-renewers' => ['authorized_renewers'],
                     'authorizedDNs-retrievers' => ['authorized_retrievers'],
                     'authorizedDNs-keyRetrievers' => ['authorized_key_retrievers'],
                     'authorizedDNs-trustedRetrievers' => ['trusted_retrievers','authorized_retrievers'],
                    );


##########################################################################
sub Configure($$@) {
##########################################################################
    
    my ($self, $config) = @_;

    # Define paths for convenience. 
    my $base = "/software/components/myproxy";

    # Retrive component configuration
    my $myproxy_config = $config->getElement($base)->getTree();

    # Save the date
    my $date = localtime();

    # Ensure MyProxy flavor is defined. Assume 'edg' by default
    # for backward compatibility.
    unless ( $myproxy_config->{flavor} ) {
      $myproxy_config->{flavor} = 'edg';
    }
    
    my $new_config;
    if ( $myproxy_config->{flavor} eq 'glite' ) {
      $new_config .= "accepted_credentials \"*\"\n";
    }
    
    # If present, loop over all of the trustedDNs (obsolete).
    if ( $myproxy_config->{trustedDNs} ) {
      $self->debug(1,"Deprecated trustedDNs found. Adding them as authorized renewers and retrievers...");
      for my $subject (@{$myproxy_config->{trustedDNs}}) {
        $self->debug(2,"Adding DN $subject");
        if ( $myproxy_config->{flavor} eq 'glite' ) {
          $new_config .= "authorized_renewers \"$subject\"\n";        
          $new_config .= "authorized_retrievers \"$subject\"\n";        
        } else {
          $new_config .= "$subject\n";        
        }
      }
    }
    
    # Loop over authorized and default DNs.
    # For each of them, there are 4 categories : renewers, retrievers, key_retrievers and trusted_retrievers.
    # Trusted retrievers are clients allowed to retrieve credentials without any additional authentication. They
    # have to be configured as retrievers too.
    # Cf man man myproxy-server.config

    for my $policy_group ('defaultDNs', 'authorizedDNs') {
      if ( $myproxy_config->{$policy_group} ) {
        $self->debug(1,"Processing policy group $policy_group...");
        for my $policy (keys(%{$myproxy_config->{$policy_group}})) {
          $self->debug(1,"Processing policy $policy...");
          for my $dn (@{$myproxy_config->{$policy_group}->{$policy}}) {
            $self->debug(2,"Adding DN $dn");
            for my $option_keyword (@{$myproxy_options{$policy_group.'-'.$policy}}) {
              $new_config .= $option_keyword . " " . $dn . "\n";
            }
          }
        }
      }
    }

    # Retrieve MyProxy configuration file path
    my $fname;
    if ( $myproxy_config->{confFile} ) {
      $fname = $myproxy_config->{confFile};
    } else {
      $fname = '/opt/edg/etc/edg-myproxy.conf'
    }

    # Read old file to do a comparaison ignoring comments.
    # If an error occurs, try to continue as the file should be overwritten or
    # another error happen.
    $self->info("Checking MyProxy server configuration (flavor: ".$myproxy_config->{flavor}.")...");
    my $old_config = '';
    if ( -f $fname ) {
      my $status = open(CONFFILE,"<$fname");
      if ( $status ) {
        my @old_config = grep (!/^#/,<CONFFILE>);
        $old_config = join "", @old_config;
        close CONFFILE;
      } else {
        $self->warn("Failed to open existing configuration file. Trying to continue...")
      }
    }
    
    # Update configuration if necessary
    my $changes = 0;
    if ( $new_config ne $old_config ) {
      $new_config = "#\n# File generated by ncm-myproxy on $date\n#\n" . $new_config;
      $changes = LC::Check::file($fname,
                                 backup => ".old",
                                 contents => $new_config,
                                );
      if ( $changes < 0 ) {
        $self->error("Error updating MyProxy server configuration file ($fname)")
      }      
    }

    # Use 'myproxy' as daemon name if undefined
    unless ( $myproxy_config->{daemonName} ) {
        $myproxy_config->{daemonName} = 'myproxy';
    }

    # Reload MyProxy daemon if running, else restart it.
    # Always restart if flavor is edg.
    my $proc = CAF::Process->new (['/sbin/service', $myproxy_config->{daemonName}, 'status'], log => $self);
    $self->info($proc->output());
    if ( $? || (($myproxy_config->{flavor} eq 'edg') && ($changes > 0)) ) {
      $self->info("Restarting MyProxy server...");
      my $proc = CAF::Process->new (['/sbin/service', $myproxy_config->{daemonName}, 'restart'], log => $self);
      $self->info($proc->output());
      if ( $? ) {
        $self->error("MyProxy server restart failed");
      }
    } elsif ( $changes > 0 ) {
      $self->info("Reloading MyProxy server...");
      my $proc = CAF::Process->new (['/sbin/service', $myproxy_config->{daemonName}, 'reload'], log => $self);
      $self->info($proc->output());
      if ( $? ) {
        $self->error("MyProxy server reload failed");
      }
    }

    return 1;
}

1;      # Required for PERL modules
